using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniJava.Frontend.Trees;
using System.IO;

namespace MiniJava.Backend
{
	public partial class CodeGen
	{
		private int nesting;
		private int labelCounter;
		public TextWriter OutputStream { get; protected set; }

		// We cannot output the method bodies directly, since local variable types
		// must be specified beforehand, and the code generator might require scratch registers
		private bool buffering;
		private StringBuilder bufferedOutput;

		public CompilerContext Context { get; protected set; }
		public MethodTree CurrentMethod { get; protected set; }
		public CodeGen(CompilerContext ctx, TextWriter stream)
		{
			Context = ctx;
			bufferedOutput = new StringBuilder();
			OutputStream = stream;
		}
		public void Generate()
		{
			EmitProgramHeader();
			foreach (var cls in Context.Classes.Values)
				EmitClass(cls);
		}
		private void WithBraces(Func<bool> func)
		{
			Emit("{");
			nesting += 4;
			func();
			nesting -= 4;
			Emit("}");
		}
		private void BeginBuffer()
		{
			buffering = true;
		}
		private StringBuilder EndBuffer()
		{
			var retval = bufferedOutput;
			buffering = false;
			bufferedOutput = new StringBuilder();
			return retval;
		}
		private void WriteBufferedLines(StringBuilder b)
		{
			OutputStream.Write(b);
		}
		private void Emit(string p)
		{
			bufferedOutput.Append(' ', nesting);
			bufferedOutput.AppendLine(p);
			if (!buffering)
			{
				OutputStream.Write(bufferedOutput);
				bufferedOutput.Clear();
			}
		}
		private string MakeLabel()
		{
			return String.Format("L" + labelCounter++.ToString("X4"));
		}
		private void EmitInsn(string insn)
		{
			Emit("  " + insn);
		}
		private void EmitLabel(string label)
		{
			Emit(label + ":");
		}
		// The mono c# compiler uses this
		private void EmitNot()
		{
			EmitInsn("ldc.i4.0");
			EmitInsn("ceq");
		}

		private int AllocScratchRegister(JavaType typ)
		{
			CurrentMethod.LocalVariableRegisters.Add(typ);
			return CurrentMethod.LocalVariableRegisters.Count - 1;
		}
		private void EmitClassHeader(ClassTree cls)
		{
		    Emit(".method public hidebysig specialname rtspecialname ");
		    Emit("instance default void '.ctor' ()  cil managed ");
			WithBraces(() =>
			{
				Emit(".maxstack 1");
				Emit("ldarg.0");
				Emit("call instance void class " + (cls.SuperClassName ?? "[mscorlib]System.Object") + "::'.ctor'()");
				Emit("ret");
				return true;
			});
		}
		private void EmitMethod(MethodTree meth)
		{
			CurrentMethod = meth;
			if (meth.IsMain)
				Emit(".method public static hidebysig default void Main() cil managed");
			else
			{
				bool isFirst = meth.EarliestDeclaringClass.Methods[meth.Name] == meth;
				Emit(".method public virtual hidebysig " + 
					(isFirst ? "newslot " : "") + "instance default");
				Emit(meth.GetCilSignature() + " cil managed");
			}
			WithBraces(() =>
			{
				if (meth.IsMain)
					Emit(".entrypoint");
				BeginBuffer();
				meth.Body.Accept(this);
				EmitInsn("ret");
				StringBuilder buffered = EndBuffer();
				if (meth.LocalVariableRegisters.Count > 0)
				{
					Emit(".locals init(" + String.Join(", ",
						meth.LocalVariableRegisters.Select(typ => typ.CilTypeName)) + ")");
				}
				WriteBufferedLines(buffered);
				return true;
			});
		}
		private void EmitClass(ClassTree cls)
		{
			Emit(String.Format(".class public auto ansi beforefieldinit {0} extends {1}",
				cls.Name, cls.SuperClassName ?? "[mscorlib]System.Object"));
			WithBraces(() =>
			{
				EmitClassHeader(cls);
				foreach (var fld in cls.Fields.Values)
					Emit(".field private " + fld.Type.CilTypeName + " " + fld.Name);
				foreach (var meth in cls.Methods.Values)
					EmitMethod(meth);
				return true;
			});
		}
		private void EmitProgramHeader()
		{
			Emit(@"// Program generated by MiniJava
.assembly MiniJavaGeneratedProgram {}
.assembly extern mscorlib {}
// MiniJava runtime helper library
.namespace MiniJava
{
  .class public auto ansi abstract sealed beforefieldinit RuntimeHelpers extends [mscorlib]System.Object
  {
    .method public static hidebysig default
    void Assert (bool assertion, string location) cil managed
    {
            .maxstack 8
            ldarg.0
            brtrue end

            ldstr ""Assertion failed at ""
            ldarg.1
            call string string::Concat(string, string)
            newobj instance void class [mscorlib]System.InvalidOperationException::'.ctor'(string)
            throw
    end:    ret
    }
  }
}");
		}
	}
}
